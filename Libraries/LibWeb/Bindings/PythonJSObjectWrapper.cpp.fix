/*
 * Copyright (c) 2025, Ladybird Browser Project
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <LibWeb/Bindings/PythonJSObjectWrapper.h>
#include <LibJS/Runtime/Object.h>
#include <LibJS/Runtime/VM.h>
#include <LibJS/Runtime/Value.h>
#include <LibJS/Runtime/PropertyKey.h>

namespace Web::Bindings {

// Define wrapper type for JS objects in Python
struct JSObjectWrapper {
    PyObject_HEAD
    JS::Object* js_obj;
    JS::Realm* realm;
};

PyTypeObject PythonJSObjectWrapper::s_js_object_wrapper_type = {
    PyVarObject_HEAD_INIT(nullptr, 0)
    .tp_name = "web.JSObject",
    .tp_basicsize = sizeof(JSObjectWrapper),
    .tp_itemsize = 0,
    .tp_dealloc = (destructor)PythonJSObjectWrapper::wrapper_dealloc,
    .tp_vectorcall_offset = 0,
    .tp_getattr = nullptr,
    .tp_setattr = nullptr,
    .tp_as_async = nullptr,
    .tp_repr = nullptr,
    .tp_as_number = nullptr,
    .tp_as_sequence = nullptr,
    .tp_as_mapping = nullptr,
    .tp_hash = nullptr,
    .tp_call = (ternaryfunc)PythonJSObjectWrapper::wrapper_call,
    .tp_str = nullptr,
    .tp_getattro = (getattrofunc)PythonJSObjectWrapper::wrapper_getattr,
    .tp_setattro = (setattrofunc)PythonJSObjectWrapper::wrapper_setattr,
    .tp_as_buffer = nullptr,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_doc = "JavaScript Object Wrapper",
    .tp_traverse = nullptr,
    .tp_clear = nullptr,
    .tp_richcompare = nullptr,
    .tp_weaklistoffset = 0,
    .tp_iter = nullptr,
    .tp_iternext = nullptr,
    .tp_methods = nullptr,
    .tp_members = nullptr,
    .tp_getset = nullptr,
    .tp_base = nullptr,
    .tp_dict = nullptr,
    .tp_descr_get = nullptr,
    .tp_descr_set = nullptr,
    .tp_dictoffset = 0,
    .tp_init = nullptr,
    .tp_alloc = nullptr,
    .tp_new = nullptr,
    .tp_free = nullptr,
    .tp_is_gc = nullptr,
    .tp_bases = nullptr,
    .tp_mro = nullptr,
    .tp_cache = nullptr,
    .tp_subclasses = nullptr,
    .tp_weaklist = nullptr,
    .tp_del = nullptr,
    .tp_version_tag = 0,
    .tp_finalize = nullptr,
};

bool PythonJSObjectWrapper::setup_js_object_wrapper_type()
{
    // Type object is already initialized
    if (PyType_Ready(&s_js_object_wrapper_type) < 0)
        return false;

    return true;
}

PyObject* PythonJSObjectWrapper::create_wrapper_for_js_object(JS::Object& obj, JS::Realm& realm)
{
    // Create a new wrapper instance
    auto* wrapper = PyObject_New(JSObjectWrapper, &s_js_object_wrapper_type);
    if (!wrapper)
        return nullptr;

    // Store JS object pointer and realm
    wrapper->js_obj = &obj;
    wrapper->realm = &realm;

    return (PyObject*)wrapper;
}

void PythonJSObjectWrapper::wrapper_dealloc(JSObjectWrapper* self)
{
    // We don't need to delete js_obj here since it's managed by JS GC
    PyObject_Del(self);
}

// Handle attribute access (obj.attr)
PyObject* PythonJSObjectWrapper::wrapper_getattr(JSObjectWrapper* self, PyObject* attr_name)
{
    // Get attribute name as C string
    const char* attr_str = PyUnicode_AsUTF8(attr_name);
    if (!attr_str)
        return nullptr;

    // Get JavaScript object and VM
    JS::Object* js_obj = self->js_obj;
    JS::Realm* realm = self->realm;
    auto& vm = realm->vm();

    // Special case for dir() support
    if (strcmp(attr_str, "__dir__") == 0) {
        // Return a callable that lists properties
        // This is a placeholder - in a real implementation we would create a function
        Py_RETURN_NONE;
    }

    // Create property key from attribute name
    auto property_name = JS::PropertyKey::from_string(vm, attr_str);
    if (property_name.is_error()) {
        PyErr_SetString(PyExc_AttributeError, "Failed to create property key");
        return nullptr;
    }

    // Get the property value
    auto property_value = js_obj->get(property_name.release_value());
    if (property_value.is_error()) {
        PyErr_SetString(PyExc_AttributeError, "Property access failed");
        return nullptr;
    }

    // Convert JS value to Python
    return PythonJSBridge::js_to_python(property_value.release_value(), vm);
}

// Handle attribute assignment (obj.attr = value)
int PythonJSObjectWrapper::wrapper_setattr(JSObjectWrapper* self, PyObject* attr_name, PyObject* value)
{
    // Get attribute name as C string
    const char* attr_str = PyUnicode_AsUTF8(attr_name);
    if (!attr_str)
        return -1;

    // Get JavaScript object and VM
    JS::Object* js_obj = self->js_obj;
    JS::Realm* realm = self->realm;
    auto& vm = realm->vm();

    // Convert Python value to JavaScript
    auto js_value = PythonJSBridge::python_to_js(value, *realm);

    // Create property key from attribute name
    auto property_name = JS::PropertyKey::from_string(vm, attr_str);
    if (property_name.is_error()) {
        PyErr_SetString(PyExc_AttributeError, "Failed to create property key");
        return -1;
    }

    // Set the property value
    auto set_result = js_obj->set(property_name.release_value(), js_value, true);
    if (set_result.is_error()) {
        PyErr_SetString(PyExc_AttributeError, "Setting property failed");
        return -1;
    }

    return 0;
}

// Handle function calls (obj())
PyObject* PythonJSObjectWrapper::wrapper_call(JSObjectWrapper* self, PyObject* args, PyObject* kwds)
{
    // Get JavaScript object and VM
    JS::Object* js_obj = self->js_obj;
    JS::Realm* realm = self->realm;
    auto& vm = realm->vm();

    // Check if the JS object is callable
    if (!js_obj->is_function()) {
        PyErr_SetString(PyExc_TypeError, "JavaScript object is not callable");
        return nullptr;
    }

    // Get function object from JS object
    auto* js_function = static_cast<JS::FunctionObject*>(js_obj);

    // Convert Python args to JS values
    GC::RootVector<JS::Value> js_args(vm.heap());
    int arg_count = PyTuple_Size(args);

    for (int i = 0; i < arg_count; i++) {
        PyObject* arg = PyTuple_GetItem(args, i);
        auto js_arg = PythonJSBridge::python_to_js(arg, *realm);
        js_args.append(js_arg);
    }

    // Call the JavaScript function
    auto result = JS::call(vm, js_function, JS::js_undefined(), js_args);
    if (result.is_error()) {
        PyErr_SetString(PyExc_RuntimeError, "JavaScript function call failed");
        return nullptr;
    }

    // Convert result to Python
    return PythonJSBridge::js_to_python(result.release_value(), vm);
}

} // namespace Web::Bindings
