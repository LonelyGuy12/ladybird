/*
 * Copyright (c) 2025, Ladybird Browser Project
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <LibWeb/Bindings/PythonDOMBindings.h>
#include <LibWeb/Bindings/PythonDOMWrapperCache.h>
#include <LibWeb/DOM/Document.h>
#include <LibWeb/DOM/Element.h>
#include <LibWeb/DOM/ParentNode.h>
#include <LibWeb/HTML/Window.h>
#include <LibWeb/CSS/CSSStyleDeclaration.h>

namespace Web::Bindings {

// Define wrapper types for DOM objects
struct PythonDocumentObject {
    PyObject_HEAD
    DOM::Document* document;
};

struct PythonElementObject {
    PyObject_HEAD
    DOM::Element* element;
};

struct PythonWindowObject {
    PyObject_HEAD
    HTML::Window* window;
};

// Static type objects
static PyTypeObject s_document_type = {0};
static PyTypeObject s_element_type = {0};
static PyTypeObject s_window_type = {0};

// Forward declarations of wrapper functions
static void document_dealloc(PythonDocumentObject* self);
static PyObject* document_get_element_by_id(PythonDocumentObject* self, PyObject* args);
static PyObject* document_query_selector(PythonDocumentObject* self, PyObject* args);
static PyObject* document_query_selector_all(PythonDocumentObject* self, PyObject* args);

static void element_dealloc(PythonElementObject* self);
static PyObject* element_get_attribute(PythonElementObject* self, PyObject* args);
static PyObject* element_set_attribute(PythonElementObject* self, PyObject* args);
static PyObject* element_get_text_content(PythonElementObject* self, void* closure);
static int element_set_text_content(PythonElementObject* self, PyObject* value, void* closure);
static PyObject* element_get_inner_html(PythonElementObject* self, void* closure);
static int element_set_inner_html(PythonElementObject* self, PyObject* value, void* closure);
static PyObject* element_find(PythonElementObject* self, PyObject* args);
static PyObject* element_select(PythonElementObject* self, PyObject* args);

static void window_dealloc(PythonWindowObject* self);
static PyObject* window_get_document(PythonWindowObject* self, void* closure);
static PyObject* window_get_location(PythonWindowObject* self, void* closure);

// Method definitions for Document type
static PyMethodDef document_methods[] = {
    {"getElementById", (PyCFunction)document_get_element_by_id, METH_VARARGS, "Get element by ID"},
    {"querySelector", (PyCFunction)document_query_selector, METH_VARARGS, "Query for a single element"},
    {"querySelectorAll", (PyCFunction)document_query_selector_all, METH_VARARGS, "Query for multiple elements"},
    {nullptr, nullptr, 0, nullptr}  // Sentinel
};

// Initialize Document type
bool PythonDocument::init_document_type()
{
    s_document_type = {
        PyVarObject_HEAD_INIT(nullptr, 0)
        .tp_name = "web.Document",
        .tp_basicsize = sizeof(PythonDocumentObject),
        .tp_itemsize = 0,
        .tp_dealloc = (destructor)document_dealloc,
        .tp_flags = Py_TPFLAGS_DEFAULT,
        .tp_doc = "DOM Document",
        .tp_methods = document_methods,
    };

    if (PyType_Ready(&s_document_type) < 0)
        return false;

    return true;
}

// Create a Python Document object from a C++ Document
PyObject* PythonDocument::create_from_cpp_document(DOM::Document& document)
{
    // Check if we already have a Python wrapper for this document
    auto* cache = document.wrapper_cache();
    if (!cache)
        document.set_wrapper_cache(make<PythonDOMWrapperCache>());

    if (auto* existing_wrapper = document.wrapper_cache()->get_wrapper(&document))
        return existing_wrapper;

    // Create a new Python wrapper
    auto* obj = PyObject_New(PythonDocumentObject, &s_document_type);
    if (!obj)
        return nullptr;

    obj->document = &document;
    
    // Store the wrapper in the cache
    document.wrapper_cache()->set_wrapper(&document, (PyObject*)obj);
    
    return (PyObject*)obj;
}

// Method definitions for Element type
static PyMethodDef element_methods[] = {
    {"getAttribute", (PyCFunction)element_get_attribute, METH_VARARGS, "Get attribute value"},
    {"setAttribute", (PyCFunction)element_set_attribute, METH_VARARGS, "Set attribute value"},
    {"find", (PyCFunction)element_find, METH_VARARGS, "Find a single child element"},
    {"select", (PyCFunction)element_select, METH_VARARGS, "Find all matching child elements"},
    {nullptr, nullptr, 0, nullptr}  // Sentinel
};

// Property getters/setters for Element type
static PyGetSetDef element_getsets[] = {
    {"textContent", (getter)element_get_text_content, (setter)element_set_text_content, "Text content", nullptr},
    {"innerHTML", (getter)element_get_inner_html, (setter)element_set_inner_html, "Inner HTML", nullptr},
    {nullptr, nullptr, nullptr, nullptr, nullptr}  // Sentinel
};

// Initialize Element type
bool PythonElement::init_element_type()
{
    s_element_type = {
        PyVarObject_HEAD_INIT(nullptr, 0)
        .tp_name = "web.Element",
        .tp_basicsize = sizeof(PythonElementObject),
        .tp_itemsize = 0,
        .tp_dealloc = (destructor)element_dealloc,
        .tp_flags = Py_TPFLAGS_DEFAULT,
        .tp_doc = "DOM Element",
        .tp_methods = element_methods,
        .tp_getset = element_getsets,
    };

    if (PyType_Ready(&s_element_type) < 0)
        return false;

    return true;
}

// Create a Python Element object from a C++ Element
PyObject* PythonElement::create_from_cpp_element(DOM::Element& element)
{
    // Check if we already have a Python wrapper for this element
    auto* document = element.document();
    if (!document)
        return nullptr;

    auto* cache = document->wrapper_cache();
    if (!cache)
        document->set_wrapper_cache(make<PythonDOMWrapperCache>());

    if (auto* existing_wrapper = document->wrapper_cache()->get_wrapper(&element))
        return existing_wrapper;

    // Create a new Python wrapper
    auto* obj = PyObject_New(PythonElementObject, &s_element_type);
    if (!obj)
        return nullptr;

    obj->element = &element;
    
    // Store the wrapper in the cache
    document->wrapper_cache()->set_wrapper(&element, (PyObject*)obj);
    
    return (PyObject*)obj;
}

// Property getters/setters for Window type
static PyGetSetDef window_getsets[] = {
    {"document", (getter)window_get_document, nullptr, "Document", nullptr},
    {"location", (getter)window_get_location, nullptr, "Location", nullptr},
    {nullptr, nullptr, nullptr, nullptr, nullptr}  // Sentinel
};

// Initialize Window type
bool PythonWindow::init_window_type()
{
    s_window_type = {
        PyVarObject_HEAD_INIT(nullptr, 0)
        .tp_name = "web.Window",
        .tp_basicsize = sizeof(PythonWindowObject),
        .tp_itemsize = 0,
        .tp_dealloc = (destructor)window_dealloc,
        .tp_flags = Py_TPFLAGS_DEFAULT,
        .tp_doc = "Window object",
        .tp_getset = window_getsets,
    };

    if (PyType_Ready(&s_window_type) < 0)
        return false;

    return true;
}

// Create a Python Window object from a C++ Window
PyObject* PythonWindow::create_from_cpp_window(HTML::Window& window)
{
    // Check if we already have a Python wrapper for this window
    auto& document = window.document();
    if (!document)
        return nullptr;

    auto* cache = document->wrapper_cache();
    if (!cache)
        document->set_wrapper_cache(make<PythonDOMWrapperCache>());

    if (auto* existing_wrapper = document->wrapper_cache()->get_wrapper(&window))
        return existing_wrapper;

    // Create a new Python wrapper
    auto* obj = PyObject_New(PythonWindowObject, &s_window_type);
    if (!obj)
        return nullptr;

    obj->window = &window;
    
    // Store the wrapper in the cache
    document->wrapper_cache()->set_wrapper(&window, (PyObject*)obj);
    
    return (PyObject*)obj;
}

// Document method implementations
static void document_dealloc(PythonDocumentObject* self)
{
    // We don't own the document, so just free the Python object
    PyObject_Del(self);
}

static PyObject* document_get_element_by_id(PythonDocumentObject* self, PyObject* args)
{
    const char* id;
    if (!PyArg_ParseTuple(args, "s", &id))
        return nullptr;

    // Convert C string to FlyString
    auto id_string = FlyString(id);
    
    // Call the document method
    auto element = self->document->get_element_by_id(id_string);
    if (!element)
        Py_RETURN_NONE;

    // Create a Python wrapper for the element
    return PythonElement::create_from_cpp_element(*element);
}

static PyObject* document_query_selector(PythonDocumentObject* self, PyObject* args)
{
    const char* selector;
    if (!PyArg_ParseTuple(args, "s", &selector))
        return nullptr;

    // Convert C string to StringView
    auto selector_view = StringView(selector);
    
    // Call the document method
    auto result = self->document->query_selector(selector_view);
    if (result.is_error() || !result.value())
        Py_RETURN_NONE;

    // Create a Python wrapper for the element
    return PythonElement::create_from_cpp_element(*result.value());
}

static PyObject* document_query_selector_all(PythonDocumentObject* self, PyObject* args)
{
    const char* selector;
    if (!PyArg_ParseTuple(args, "s", &selector))
        return nullptr;

    // Convert C string to StringView
    auto selector_view = StringView(selector);
    
    // Call the document method
    auto result = self->document->query_selector_all(selector_view);
    if (result.is_error())
        Py_RETURN_NONE;

    auto& node_list = result.value();
    
    // Create a Python list to hold the elements
    PyObject* list = PyList_New(node_list->length());
    if (!list)
        return nullptr;

    // Add elements to the list
    for (size_t i = 0; i < node_list->length(); ++i) {
        auto& node = node_list->item(i);
        if (is<DOM::Element>(node)) {
            auto& element = static_cast<DOM::Element&>(node);
            PyObject* py_element = PythonElement::create_from_cpp_element(element);
            if (!py_element) {
                py_element = Py_None;
                Py_INCREF(Py_None);
            }
            PyList_SET_ITEM(list, i, py_element); // PyList_SET_ITEM steals reference
        } else {
            Py_INCREF(Py_None);
            PyList_SET_ITEM(list, i, Py_None);
        }
    }

    return list;
}

// Element method implementations
static void element_dealloc(PythonElementObject* self)
{
    // We don't own the element, so just free the Python object
    PyObject_Del(self);
}

static PyObject* element_get_attribute(PythonElementObject* self, PyObject* args)
{
    const char* name;
    if (!PyArg_ParseTuple(args, "s", &name))
        return nullptr;

    // Convert C string to FlyString
    auto name_string = FlyString(name);
    
    // Get the attribute
    auto value = self->element->get_attribute(name_string);
    if (!value.has_value())
        Py_RETURN_NONE;

    // Return the attribute value as a Python string
    return PyUnicode_FromString(value->characters());
}

static PyObject* element_set_attribute(PythonElementObject* self, PyObject* args)
{
    const char* name;
    const char* value;
    if (!PyArg_ParseTuple(args, "ss", &name, &value))
        return nullptr;

    // Convert C strings to FlyString and String
    auto name_string = FlyString(name);
    auto value_string = String(value);
    
    // Set the attribute
    auto result = self->element->set_attribute(name_string, value_string);
    if (result.is_error()) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to set attribute");
        return nullptr;
    }

    Py_RETURN_NONE;
}

static PyObject* element_get_text_content(PythonElementObject* self, void* closure)
{
    (void)closure;
    
    // Get text content
    auto text = self->element->text_content();
    if (!text.has_value())
        Py_RETURN_NONE;

    // Return as Python string
    return PyUnicode_FromString(text->to_string().characters());
}

static int element_set_text_content(PythonElementObject* self, PyObject* value, void* closure)
{
    (void)closure;
    
    if (!PyUnicode_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "Text content must be a string");
        return -1;
    }

    const char* text = PyUnicode_AsUTF8(value);
    if (!text)
        return -1;

    // Convert C string to Utf16String
    auto text_string = Utf16String::from_utf8(text).release_value();
    
    // Set text content
    self->element->set_text_content(text_string);
    
    return 0;
}

static PyObject* element_get_inner_html(PythonElementObject* self, void* closure)
{
    (void)closure;
    
    // Get inner HTML
    auto result = self->element->inner_html();
    if (result.is_error())
        Py_RETURN_NONE;

    auto html = result.release_value();
    
    // Return as Python string
    return PyUnicode_FromString(html.characters());
}

static int element_set_inner_html(PythonElementObject* self, PyObject* value, void* closure)
{
    (void)closure;
    
    if (!PyUnicode_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "Inner HTML must be a string");
        return -1;
    }

    const char* html = PyUnicode_AsUTF8(value);
    if (!html)
        return -1;

    // Convert C string to StringView
    auto html_view = StringView(html);
    
    // Set inner HTML
    auto result = self->element->set_inner_html(html_view);
    if (result.is_error()) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to set inner HTML");
        return -1;
    }
    
    return 0;
}

static PyObject* element_find(PythonElementObject* self, PyObject* args)
{
    const char* selector;
    if (!PyArg_ParseTuple(args, "s", &selector))
        return nullptr;

    // Convert C string to StringView
    auto selector_view = StringView(selector);
    
    // Find element
    auto result = self->element->query_selector(selector_view);
    if (result.is_error() || !result.value())
        Py_RETURN_NONE;

    // Create Python wrapper for element
    return PythonElement::create_from_cpp_element(*result.value());
}

static PyObject* element_select(PythonElementObject* self, PyObject* args)
{
    const char* selector;
    if (!PyArg_ParseTuple(args, "s", &selector))
        return nullptr;

    // Convert C string to StringView
    auto selector_view = StringView(selector);
    
    // Select elements
    auto result = self->element->query_selector_all(selector_view);
    if (result.is_error())
        Py_RETURN_NONE;

    auto& node_list = result.value();
    
    // Create a Python list to hold the elements
    PyObject* list = PyList_New(node_list->length());
    if (!list)
        return nullptr;

    // Add elements to the list
    for (size_t i = 0; i < node_list->length(); ++i) {
        auto& node = node_list->item(i);
        if (is<DOM::Element>(node)) {
            auto& element = static_cast<DOM::Element&>(node);
            PyObject* py_element = PythonElement::create_from_cpp_element(element);
            if (!py_element) {
                py_element = Py_None;
                Py_INCREF(Py_None);
            }
            PyList_SET_ITEM(list, i, py_element); // PyList_SET_ITEM steals reference
        } else {
            Py_INCREF(Py_None);
            PyList_SET_ITEM(list, i, Py_None);
        }
    }

    return list;
}

// Window method implementations
static void window_dealloc(PythonWindowObject* self)
{
    // We don't own the window, so just free the Python object
    PyObject_Del(self);
}

static PyObject* window_get_document(PythonWindowObject* self, void* closure)
{
    (void)closure;
    
    // Get document
    auto& document = self->window->document();
    if (!document)
        Py_RETURN_NONE;

    // Create Python wrapper for document
    return PythonDocument::create_from_cpp_document(*document);
}

static PyObject* window_get_location(PythonWindowObject* self, void* closure)
{
    (void)closure;
    
    // Get location
    auto& location = self->window->location();
    if (!location)
        Py_RETURN_NONE;

    // For now, just return the URL as a string
    auto href = location->href();
    return PyUnicode_FromString(href.to_string().characters());
}

// Initialize all DOM bindings
bool initialize_python_dom_bindings()
{
    if (!PythonDocument::init_document_type())
        return false;
        
    if (!PythonElement::init_element_type())
        return false;
        
    if (!PythonWindow::init_window_type())
        return false;
        
    return true;
}

} // namespace Web::Bindings
