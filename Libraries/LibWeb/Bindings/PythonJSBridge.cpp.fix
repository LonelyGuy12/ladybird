/*
 * Copyright (c) 2025, Ladybird Browser Project
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <LibWeb/Bindings/PythonJSBridge.h>
#include <LibWeb/Bindings/PythonJSObjectWrapper.h>
#include <LibJS/Runtime/Array.h>
#include <LibJS/Runtime/Object.h>
#include <LibJS/Runtime/PrimitiveString.h>
#include <LibJS/Runtime/VM.h>
#include <LibJS/Runtime/Value.h>
#include <LibJS/Runtime/PropertyKey.h>
#include <Python.h>

namespace Web::Bindings {

// Static bridge initialization flag
bool PythonJSBridge::s_bridge_initialized = false;

// Static Python type objects
PyObject* PythonJSBridge::s_js_proxy_type = nullptr;
PyObject* PythonJSBridge::s_py_proxy_type = nullptr;

bool PythonJSBridge::initialize_bridge()
{
    if (s_bridge_initialized)
        return true;

    // Initialize the Python-JS object wrapper type
    if (!PythonJSObjectWrapper::setup_js_object_wrapper_type())
        return false;

    s_bridge_initialized = true;
    return true;
}

JS::Value PythonJSBridge::python_to_js(PyObject* py_obj, JS::Realm& realm)
{
    if (!py_obj)
        return JS::js_null();

    auto& vm = realm.vm();

    // Handle Python None (-> JS null)
    if (py_obj == Py_None)
        return JS::js_null();

    // Handle Python bool (-> JS boolean)
    if (PyBool_Check(py_obj))
        return JS::Value(py_obj == Py_True);

    // Handle Python int (-> JS number)
    if (PyLong_Check(py_obj)) {
        long value = PyLong_AsLong(py_obj);
        if (value == -1 && PyErr_Occurred()) {
            PyErr_Clear();
            return JS::js_undefined();
        }
        return JS::Value(static_cast<double>(value));
    }

    // Handle Python float (-> JS number)
    if (PyFloat_Check(py_obj)) {
        double value = PyFloat_AsDouble(py_obj);
        if (value == -1.0 && PyErr_Occurred()) {
            PyErr_Clear();
            return JS::js_undefined();
        }
        return JS::Value(value);
    }

    // Handle Python str (-> JS string)
    if (PyUnicode_Check(py_obj)) {
        const char* str = PyUnicode_AsUTF8(py_obj);
        if (!str) {
            PyErr_Clear();
            return JS::js_undefined();
        }
        return JS::js_string(vm, str);
    }

    // Handle Python dict (-> JS object)
    if (PyDict_Check(py_obj)) {
        // Create a new JS object
        auto js_obj = JS::Object::create(realm, nullptr);

        // Get dict items and add them to JS object
        PyObject* key = nullptr;
        PyObject* value = nullptr;
        Py_ssize_t pos = 0;

        while (PyDict_Next(py_obj, &pos, &key, &value)) {
            // Only use string keys
            if (!PyUnicode_Check(key))
                continue;

            const char* key_str = PyUnicode_AsUTF8(key);
            if (!key_str)
                continue;

            // Convert Python value to JS
            JS::Value js_value = python_to_js(value, realm);

            // Create property key and set the value
            auto property_key = JS::PropertyKey::from_string(vm, key_str);
            if (property_key.is_error())
                continue;

            auto result = js_obj->set(property_key.release_value(), js_value, true);
            if (result.is_error())
                continue;
        }

        return js_obj;
    }

    // Handle Python list (-> JS array)
    if (PyList_Check(py_obj)) {
        // Create a new JS array
        auto js_array = JS::Array::create(realm);

        // Get list length
        Py_ssize_t length = PyList_Size(py_obj);

        // Add list items to JS array
        for (Py_ssize_t i = 0; i < length; i++) {
            PyObject* item = PyList_GetItem(py_obj, i);
            if (!item)
                continue;

            // Convert Python item to JS
            JS::Value js_value = python_to_js(item, realm);

            // Set array element
            auto property_key = JS::PropertyKey(static_cast<u32>(i));
            auto result = js_array->set(property_key, js_value, true);
            if (result.is_error())
                continue;
        }

        return js_array;
    }

    // For now, just return undefined for other types
    return JS::js_undefined();
}

PyObject* PythonJSBridge::js_to_python(JS::Value js_val, JS::VM& vm)
{
    // Handle JS undefined and null
    if (js_val.is_undefined() || js_val.is_null())
        Py_RETURN_NONE;

    // Handle JS boolean
    if (js_val.is_boolean())
        return js_val.as_bool() ? Py_True : Py_False;

    // Handle JS number
    if (js_val.is_number()) {
        double value = js_val.as_double();
        
        // Check if it's an integer
        if (value == (int64_t)value)
            return PyLong_FromLongLong((int64_t)value);
        
        return PyFloat_FromDouble(value);
    }

    // Handle JS string
    if (js_val.is_string()) {
        auto str = js_val.as_string().string();
        return PyUnicode_FromString(str.characters());
    }

    // Handle JS object (convert to Python dict or list)
    if (js_val.is_object()) {
        auto& obj = js_val.as_object();

        // Handle arrays differently
        if (obj.is_array()) {
            auto& array = static_cast<JS::Array&>(obj);
            auto length_result = array.indexed_property_length();
            if (length_result.is_error())
                return PyList_New(0); // Return empty list on error
                
            Py_ssize_t length = static_cast<Py_ssize_t>(length_result.release_value());
            PyObject* list = PyList_New(length);

            // Add array elements to Python list
            for (Py_ssize_t i = 0; i < length; i++) {
                auto index_key = JS::PropertyKey(static_cast<u32>(i));
                auto value_result = obj.get(index_key);
                if (value_result.is_error())
                    continue;

                PyObject* py_value = js_to_python(value_result.release_value(), vm);
                if (!py_value)
                    py_value = Py_None;
                
                PyList_SetItem(list, i, py_value); // PyList_SetItem steals reference
            }

            return list;
        }

        // Regular object -> Python dict
        PyObject* dict = PyDict_New();

        // Get all enumerable properties
        auto properties_result = obj.get_own_properties(JS::PropertyKind::Key);
        if (properties_result.is_error())
            return dict; // Return empty dict on error
            
        auto properties = properties_result.release_value();

        for (auto& property : properties) {
            auto value_result = obj.get(property.key);
            if (value_result.is_error())
                continue;

            // Convert property key to string
            PyObject* py_key = nullptr;
            if (property.key.is_symbol()) {
                // Skip symbols for now
                continue;
            } else {
                auto key_str = property.key.to_string();
                py_key = PyUnicode_FromString(key_str.characters());
            }

            if (!py_key)
                continue;

            // Convert value to Python
            PyObject* py_value = js_to_python(value_result.release_value(), vm);
            if (!py_value) {
                Py_DECREF(py_key);
                continue;
            }

            // Add key-value pair to dict
            if (PyDict_SetItem(dict, py_key, py_value) < 0) {
                Py_DECREF(py_key);
                Py_DECREF(py_value);
                continue;
            }

            Py_DECREF(py_key);
            Py_DECREF(py_value);
        }

        return dict;
    }

    // Default: return None
    Py_RETURN_NONE;
}

PyObject* PythonJSBridge::call_js_function(String const& function_name, PyObject* args, JS::Realm& realm)
{
    auto& vm = realm.vm();

    // Create property key for function name
    auto property_key_result = JS::PropertyKey::from_string(vm, function_name);
    if (property_key_result.is_error()) {
        PyErr_SetString(PyExc_RuntimeError, "Invalid function name");
        return nullptr;
    }
    auto property_key = property_key_result.release_value();

    // Get the function from global object
    auto global_object = realm.global_object();
    auto function_result = global_object.get(property_key);
    if (function_result.is_error() || !function_result.release_value().is_function()) {
        PyErr_SetString(PyExc_AttributeError, "Function not found");
        return nullptr;
    }
    auto js_function = function_result.release_value().as_function();

    // Convert Python arguments to JS values
    GC::RootVector<JS::Value> js_args(vm.heap());
    int arg_count = PyTuple_Size(args);

    for (int i = 0; i < arg_count; i++) {
        PyObject* arg = PyTuple_GetItem(args, i);
        js_args.append(python_to_js(arg, realm));
    }

    // Call JS function
    auto call_result = JS::call(vm, &js_function, &global_object, js_args.span());
    if (call_result.is_error()) {
        PyErr_SetString(PyExc_RuntimeError, "JavaScript function call failed");
        return nullptr;
    }

    // Convert result back to Python
    return js_to_python(call_result.release_value(), vm);
}

JS::Value PythonJSBridge::call_python_function(PyObject* func, GC::RootVector<JS::Value>& js_args, JS::Realm& realm)
{
    auto& vm = realm.vm();

    // Check if the object is callable
    if (!PyCallable_Check(func))
        return JS::js_undefined();

    // Convert JS arguments to Python tuple
    PyObject* py_args = PyTuple_New(js_args.size());
    for (size_t i = 0; i < js_args.size(); i++) {
        PyObject* arg = js_to_python(js_args[i], vm);
        PyTuple_SetItem(py_args, i, arg); // PyTuple_SetItem steals reference
    }

    // Call the Python function
    PyObject* result = PyObject_CallObject(func, py_args);
    Py_DECREF(py_args);

    if (!result) {
        PyErr_Print();
        return JS::js_undefined();
    }

    // Convert result to JS
    auto js_result = python_to_js(result, realm);
    Py_DECREF(result);

    return js_result;
}

PyObject* PythonJSBridge::get_js_global_object()
{
    // Placeholder implementation - would need to be connected to current JS realm
    return nullptr;
}

bool PythonJSBridge::setup_bridge_in_context(PyObject* globals, JS::Realm& realm)
{
    if (!globals || !PyDict_Check(globals))
        return false;

    // Add bridge utilities to Python globals
    // This would be expanded in a real implementation

    return true;
}

} // namespace Web::Bindings
